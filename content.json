{"meta":{"title":"程序员三时","subtitle":"","description":"程序员三时 个人博客, 分享经验干货，记录开发历程,乐于分享，爱好码字，沉迷于折腾","author":"程序员三时","url":"http://example.com"},"pages":[],"posts":[{"title":"OpenAI ChatGPT最新国内注册教程，简单快速- 百分百成功","slug":"百分百成功","date":"2023-04-25T06:00:58.000Z","updated":"2023-04-25T06:03:22.437Z","comments":true,"path":"2023/04/25/百分百成功clhssntl00000tt4e7m3ccylk.html","link":"","permalink":"http://example.com/2023/04/25/%E7%99%BE%E5%88%86%E7%99%BE%E6%88%90%E5%8A%9Fclhssntl00000tt4e7m3ccylk.html","excerpt":"","text":"我们知道openai最近火爆，全网都在用都在体验，可是由于国内相关原因，他们停止了向中国，台湾地区提供服务，并且封禁了大量的账号 我们无法正常使用和注册 下面方法是我自己亲自实践保证有效 OpenAI官网 点进去注册 这里提供一个访问外面的工具 以下是 OpenAI ChatGPT 的国内注册步骤： 首先需要具备以下条件： 可以访问外网（https://chat.openai.com/auth/login） 国外手机能接收短信验证码（推荐 https://sms-activate.org），虚拟电话不行 尽量不要使用国内的邮箱，推荐使用 Gmail 注册 SMS 接收验证码平台：推荐使用 SMS Activate，注册需要邮箱和密码，激活完成后可以进行充值。目前最低充值金额为 1 美元，可以用支付宝进行支付。 注册 OpenAI ChatGPT：用浏览器无痕模式访问 OpenAI 官网（https://chat.openai.com/auth/login），点击 “Sign up” 进行注册。输入常用的个人邮箱地址，点击 “Continue”，会自动发送一封激活邮件到你的邮箱。 验证邮件后会自动跳转到 “Verify Your Phone Number” 页面，此时需要使用手机接收验证码。但国内手机号码无法接收，可以使用 SMS Activate 提供的临时手机号码。 购买临时手机号码：在 SMS Activate 中，打开临时手机号码购买页面，选择国家（例如巴西），点击 “Buy”，支付后即可获得临时手机号码。 验证手机号码：回到 OpenAI 的 “Verify Your Phone Number” 页面，将购买的临时手机号码复制到输入框中，点击 “Send Code” 发送验证码。到 SMS Activate 中查看临时手机号码短信，复制验证码输入到 OpenAI 的 “Verify Your Phone Number” 页面，点击 “Verify” 完成验证。 至此，国内用户已经成功注册 OpenAI ChatGPT，可以使用该神器聊天并提供各种帮助了。请注意，帮助别人或被帮助时，一定要遵守官方规定，不要违法或违规。 这个是我之前自己注册账号还有余额，需要可以我来帮你接收短信 选择OpenAI 激活服务买入 遇到任何问题可以与我交流 另外我还提供了自己的免费的OpenAI chatGPT服务 可以进群体验","categories":[{"name":"AI-ChatGPT","slug":"AI-ChatGPT","permalink":"http://example.com/categories/AI-ChatGPT/"}],"tags":[{"name":"openai","slug":"openai","permalink":"http://example.com/tags/openai/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://example.com/tags/ChatGPT/"}],"keywords":[{"name":"AI-ChatGPT","slug":"AI-ChatGPT","permalink":"http://example.com/categories/AI-ChatGPT/"}]},{"title":"细说SpringBoot多种场景传参模式","slug":"细说SpringBoot多种场景传参模式","date":"2023-04-18T07:57:22.590Z","updated":"2023-04-18T08:00:18.133Z","comments":true,"path":"2023/04/18/细说SpringBoot多种场景传参模式clhssntl80001tt4ed4j7ef2q.html","link":"","permalink":"http://example.com/2023/04/18/%E7%BB%86%E8%AF%B4SpringBoot%E5%A4%9A%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%BC%A0%E5%8F%82%E6%A8%A1%E5%BC%8Fclhssntl80001tt4ed4j7ef2q.html","excerpt":"","text":"web技术我们知道常见的web技术也就是网站开发，分为静态网站，和动态网站，动态网站技术常见的有三种，分别是 jsp java web，asp c# web,php web但是它们对应请求request,响应response 都是一样的我们用java web开发动态网站用的mvc框架就是，springmvc，当然我们现在用的是springboot 它只是对spirng全家桶的一个整合框架，他本质不是一个新的框架，内部还是spirng+springmvc 多种传参方式传统参数传递我们知道controller方法中会帮我注入HttpServletRequest对象，我们可以通过request.getParameter(&quot;参数名&quot;)来直接获取参数， 123456789@RequestMapping(&quot;/test01&quot;)public ModelAndView test01(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(username); System.out.println(password); return null;&#125; 简单类型参数映射 如果请求参数和Controller方法的形参同名，可以直接接收 如果请求参数和Controller方法的形参不同名，可以使用@RequestParam注解贴在形参前，设置对应的参数名称 注意这里只能是基本数据类型比如string，int，long，boolean等类型 123456789101112131415@RequestMapping(&quot;/test02_1&quot;)public ModelAndView test02_1(String username,String password)&#123; System.out.println(username); System.out.println(password); return null;&#125;@RequestMapping(&quot;/test02_2&quot;)public ModelAndView test02_2(@RequestParam(&quot;username&quot;) String name,@RequestParam(value = &quot;password&quot;,defaultValue = &quot;1234987&quot;) String pwd)&#123; //使用了@RequestParam的参数不能传空值 // required:表示是否必须要传值 // defaultValue:当没有该请求参数时,SpringMVC给请求参数的默认值 System.out.println(name); System.out.println(pwd); return null;&#125; 复杂对象映射当然在实际项目中，我们会有很多个参数，一般超过两个参数我们就要封装成对象，通过对象传参数，不然这么一个一个写会麻烦，代码冗余，不美观，不能复用 此时能够自动把参数封装到形参的对象属性上： 请求参数必须和对象的属性同名 此时对象会直接放入request作用域中，名称为类型首字母小写 @ModelAttribute设置请求参数绑定到对象中并传到视图页面的key值 12345678910@RequestMapping(&quot;/test03&quot;)public ModelAndView test03(@ModelAttribute(&quot;stu&quot;) Student student)&#123; /*可以使用对象作为方法的形参,同时接受接受前台的多个请求参数 SpringMVC会基于同名匹配,将请求参数的值注入对应的对象中的属性中 @ModelAttribute起名字key值*/ System.out.println(student); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;test2&quot;); return mv;&#125; 如果需要body里面json传参数需要在形参前面加上@RequestBody 会自动完成映射 1234@PostMapping(&quot;/register&quot;) public Result bodyParams(@RequestBody Users users) &#123; return ResultResponse.success(users); &#125; 数组和集合类型参数当前台页面传来的参数是参数名相同，参数值不同的多个参数时，可以直接封装到方法的数组类型的形参中 比如批量删除时传来的参数 123456/*对于参数名相同的多个请求参数,可以直接使用数组作为方法的形参接收 可以使用对象中的集合属性接收*/@DeleteMapping(&quot;/del&quot;)public Result listParams(String[] ids) &#123; return ResultResponse.success(ids);&#125; Restful风格传参Restful是一种软件架构风格，严格上说是一种编码风格，其充分利用 HTTP 协议本身语义从而提供了一组设计原则和约束条件。 主要用于客户端和服务器交互类的软件，该风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 在后台，RequestMapping标签后，可以用{参数名}方式传参，同时需要在形参前加注解@PathVarible 123456@RequestMapping(&quot;/delete/&#123;id&#125;&quot;)public ModelAndView test4(@PathVariable(&quot;id&quot;)Long id)&#123; System.out.println(&quot;delete&quot;); System.out.println(id); return null;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"}]},{"title":"集合遍历与循环多种方式","slug":"集合遍历与循环多种方式","date":"2023-04-17T17:39:52.000Z","updated":"2023-04-18T07:35:01.464Z","comments":true,"path":"2023/04/18/集合遍历与循环多种方式clhssntle0004tt4e03lba5ic.html","link":"","permalink":"http://example.com/2023/04/18/%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8Fclhssntle0004tt4e03lba5ic.html","excerpt":"","text":"前言Java中集合是非常常用非常重要的 ，应用是十分广泛的，作为集合这种数据结构，遍历循环方式也有很多种我们可以梳理总结不同的遍历方式，方便理解和运用 List 遍历方式 List继承了Collection，是有序的列表。 实现类有ArrayList、LinkedList、Vector、Stack等 ArrayList是基于数组实现的，是一个数组队列。可以动态的增加容量！ LinkedList是基于链表实现的，是一个双向循环列表。可以被当做堆栈使用！ Vector是基于数组实现的，是一个矢量队列，是线程安全的！ Stack是基于数组实现的，是栈，它继承与Vector，特性是FILO（先进后出）！ 所有list集合都是迭代器Iterator子类也都统称迭代器，可以通过迭代器方式去循环便利 第一种方式 迭代器遍历123456789101112List a= new ArrayList(); a.add(1); a.add(2); a.add(3); //获取迭代器 Iterator b=a.iterator(); //判断是否有下一个值 while (b.hasNext())&#123; //取出这个值 System.out.println(b.next()); &#125; 第二种方式 1234567List a= new ArrayList(); a.add(1); a.add(2); a.add(3); for(Iterator iterator=a.iterator();iterator.hasNext();)&#123; System.out.println(iterator.next()); &#125; 第三种方式 foreach 遍历 1234567List a= new ArrayList(); a.add(1); a.add(2); a.add(3); for(Object o:a)&#123; System.out.println(o); &#125; 第四种方式 fori 遍历 1234567List a= new ArrayList(); a.add(1); a.add(2); a.add(3); for(int i=0;i&lt;a.size();i++)&#123; System.out.println(a.get(i)); &#125; Map遍历方式 按照key方式来遍历 12345678910Map a=new HashMap(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); a.put(&quot;c&quot;,3); //获取所以key Set key=a.keySet(); for(Object o:key)&#123; //通过key 来获取所有值 System.out.println(a.get(o)); &#125; 通过Map.entrySet使用iterator遍历key和value 1234567891011Map a=new HashMap(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); a.put(&quot;c&quot;,3); // 获取Iterator Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = a.entrySet().iterator(); //遍历 while (it.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; 通过Map.entrySet遍历key和value，推荐，尤其是容量大时 1234567891011Map a=new HashMap(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); a.put(&quot;c&quot;,3); for ( Object o : a.entrySet()) &#123; //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 Map.Entry&lt;String,Integer&gt; d=(Map.Entry&lt;String,Integer&gt; )o; System.out.println(&quot;key= &quot; + d.getKey() + &quot; and value= &quot; + d.getValue()); &#125; 通过Map.values()遍历所有的value，但不能遍历key 12345678Map a = new HashMap(); a.put(&quot;a&quot;, 1); a.put(&quot;b&quot;, 2); a.put(&quot;c&quot;, 3); for (Object o : a.values()) &#123; System.out.println(o); &#125; Stream流API遍历 stream集合遍历forEach 1234567891011List&lt;String&gt; a=new ArrayList&lt;&gt;();a.add(&quot;judy&quot;);a.add(&quot;Tom&quot;);//lambda表达式a.stream().forEach(s -&gt; System.out.println(s));a.stream().forEach(s -&gt; &#123; System.out.println(s); System.out.println(2);&#125;);","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"},{"name":"Map","slug":"Map","permalink":"http://example.com/tags/Map/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"}]}]}