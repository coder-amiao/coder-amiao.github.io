{"meta":{"title":"三时","subtitle":"","description":"程序员三时 个人博客, 分享经验干货，记录开发历程,乐于分享，爱好码字，沉迷于折腾","author":"程序员三时","url":"http://example.com"},"pages":[],"posts":[{"title":"集合遍历与循环多种方式","slug":"集合遍历与循环多种方式","date":"2023-04-17T17:39:52.000Z","updated":"2023-04-17T17:43:58.739Z","comments":true,"path":"2023/04/18/集合遍历与循环多种方式clgly9g7p0000ua6o1yvy4a0p.html","link":"","permalink":"http://example.com/2023/04/18/%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8Fclgly9g7p0000ua6o1yvy4a0p.html","excerpt":"","text":"前言Java中集合是非常常用非常重要的 ，应用是十分广泛的，作为集合这种数据结构，遍历循环方式也有很多种我们可以梳理总结不同的遍历方式，方便理解和运用 List 遍历方式 List继承了Collection，是有序的列表。 实现类有ArrayList、LinkedList、Vector、Stack等 ArrayList是基于数组实现的，是一个数组队列。可以动态的增加容量！ LinkedList是基于链表实现的，是一个双向循环列表。可以被当做堆栈使用！ Vector是基于数组实现的，是一个矢量队列，是线程安全的！ Stack是基于数组实现的，是栈，它继承与Vector，特性是FILO（先进后出）！ 所有list集合都是迭代器Iterator子类也都统称迭代器，可以通过迭代器方式去循环便利 第一种方式 迭代器遍历123456789101112List a= new ArrayList(); a.add(1); a.add(2); a.add(3); //获取迭代器 Iterator b=a.iterator(); //判断是否有下一个值 while (b.hasNext())&#123; //取出这个值 System.out.println(b.next()); &#125; 第二种方式 1234567List a= new ArrayList(); a.add(1); a.add(2); a.add(3); for(Iterator iterator=a.iterator();iterator.hasNext();)&#123; System.out.println(iterator.next()); &#125; 第三种方式 foreach 遍历 1234567List a= new ArrayList(); a.add(1); a.add(2); a.add(3); for(Object o:a)&#123; System.out.println(o); &#125; 第四种方式 fori 遍历 1234567List a= new ArrayList(); a.add(1); a.add(2); a.add(3); for(int i=0;i&lt;a.size();i++)&#123; System.out.println(a.get(i)); &#125; Map遍历方式 按照key方式来遍历 12345678910Map a=new HashMap(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); a.put(&quot;c&quot;,3); //获取所以key Set key=a.keySet(); for(Object o:key)&#123; //通过key 来获取所有值 System.out.println(a.get(o)); &#125; 通过Map.entrySet使用iterator遍历key和value 1234567891011Map a=new HashMap(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); a.put(&quot;c&quot;,3); // 获取Iterator Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = a.entrySet().iterator(); //遍历 while (it.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; 通过Map.entrySet遍历key和value，推荐，尤其是容量大时 1234567891011Map a=new HashMap(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); a.put(&quot;c&quot;,3); for ( Object o : a.entrySet()) &#123; //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 Map.Entry&lt;String,Integer&gt; d=(Map.Entry&lt;String,Integer&gt; )o; System.out.println(&quot;key= &quot; + d.getKey() + &quot; and value= &quot; + d.getValue()); &#125; 通过Map.values()遍历所有的value，但不能遍历key 12345678Map a = new HashMap(); a.put(&quot;a&quot;, 1); a.put(&quot;b&quot;, 2); a.put(&quot;c&quot;, 3); for (Object o : a.values()) &#123; System.out.println(o); &#125; Stream流API遍历 stream集合遍历forEach 1234567891011List&lt;String&gt; a=new ArrayList&lt;&gt;();a.add(&quot;judy&quot;);a.add(&quot;Tom&quot;);//lambda表达式a.stream().forEach(s -&gt; System.out.println(s));a.stream().forEach(s -&gt; &#123; System.out.println(s); System.out.println(2);&#125;);","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"},{"name":"Map","slug":"Map","permalink":"http://example.com/tags/Map/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"}]},{"title":"轻松上手SpringBoot+SpringSecurity+JWT实RESTfulAPI权限控制实战","slug":"轻松上手SpringBoot+SpringSecurity+JWT实RESTfulAPI权限控制实战","date":"2023-04-17T08:23:50.342Z","updated":"2023-04-17T17:44:30.439Z","comments":true,"path":"2023/04/17/轻松上手SpringBoot+SpringSecurity+JWT实RESTfulAPI权限控制实战clgly9g830009ua6obxf5gye9.html","link":"","permalink":"http://example.com/2023/04/17/%E8%BD%BB%E6%9D%BE%E4%B8%8A%E6%89%8BSpringBoot+SpringSecurity+JWT%E5%AE%9ERESTfulAPI%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%AE%9E%E6%88%98clgly9g830009ua6obxf5gye9.html","excerpt":"","text":"前言我们知道在项目开发中，后台开发权限认证是非常重要的，springboot 中常用熟悉的权限认证框架有，shiro,还有就是springboot 全家桶的 security当然他们各有各的好处，但是我比较喜欢springboot自带的权限认证框架 12345&lt;!--springboot 权限认证--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 与springboot天然集成，功能强大 快速上手主要实现 Spring Security 的安全认证，结合 RESTful API 的风格，使用无状态的环境。 主要实现是通过请求的 URL ，通过过滤器来做不同的授权策略操作，为该请求提供某个认证的方法，然后进行认证，授权成功返回授权实例信息，供服务调用。 基于Token的身份验证的过程如下: 用户通过用户名和密码发送请求。程序验证。程序返回一个签名的token 给客户端。客户端储存token,并且每次用于每次发送请求。服务端验证token并返回数据。每一次请求都需要token，所以每次请求都会去验证用户身份，所以这里必须要使用缓存， 流程图JWT JSON Web Token 验证流程图 添加Spring Security和JWT依赖项 12345678910&lt;!--springboot 权限认证--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jwt 认证--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt; 生成JWT toke 因为要生成JWT toke 所以就写了一个工具类JwtTokenUtil 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package cn.soboys.kmall.security.utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Component;import java.io.Serializable;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.function.Function;/** * @author kenx * @version 1.0 * @date 2021/8/5 22:28 * @webSite https://www.soboys.cn/ */@Componentpublic class JwtTokenUtil implements Serializable &#123; private static final long serialVersionUID = -2550185165626007488L; public static final long JWT_TOKEN_VALIDITY = 7*24*60*60; private String secret=&quot;TcUF7CC8T3txmfQ38pYsQ3KY&quot;; public String getUsernameFromToken(String token) &#123; return getClaimFromToken(token, Claims::getSubject); &#125; public String generateToken(String username) &#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); return doGenerateToken(claims, username); &#125; public Boolean validateToken(String token, UserDetails userDetails) &#123; final String username = getUsernameFromToken(token); return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token)); &#125; public &lt;T&gt; T getClaimFromToken(String token, Function&lt;Claims, T&gt; claimsResolver) &#123; final Claims claims = getAllClaimsFromToken(token); return claimsResolver.apply(claims); &#125; private Claims getAllClaimsFromToken(String token) &#123; return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody(); &#125; private Boolean isTokenExpired(String token) &#123; final Date expiration = getExpirationDateFromToken(token); return expiration.before(new Date()); &#125; public Date getExpirationDateFromToken(String token) &#123; return getClaimFromToken(token, Claims::getExpiration); &#125; private String doGenerateToken(Map&lt;String, Object&gt; claims, String subject) &#123; return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis())) .setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY*1000)).signWith(SignatureAlgorithm.HS512, secret).compact(); &#125;&#125; 注入数据源这里我们使用数据库作为权限控制数据保存，所以就要注入数据源，进行权限认证Spring Security提供了 UserDetailsService接口 用于用户身份认证,和UserDetails实体类，用于保存用户信息，（用户凭证，权限等） 看源码 12345package org.springframework.security.core.userdetails;public interface UserDetailsService &#123; UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;&#125; 12345678910111213141516package org.springframework.security.core.userdetails;public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();&#125; 所以我们分为两步走: 自己的User实体类继承Spring SecurityUserDetails 保存相关权限信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package cn.soboys.kmall.security.entity;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonIgnore;import lombok.Data;import lombok.EqualsAndHashCode;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.io.Serializable;import java.time.LocalDateTime;import java.util.*;/** * &lt;p&gt; * 用户表 * &lt;/p&gt; * * @author kenx * @since 2021-08-06 */@Data@EqualsAndHashCode(callSuper = false)@TableName(&quot;t_user&quot;)public class User implements Serializable, UserDetails &#123; private static final long serialVersionUID = 1L; /** * 用户ID */ @TableId(value = &quot;USER_ID&quot;, type = IdType.AUTO) private Long userId; /** * 用户名 */ @TableField(&quot;USERNAME&quot;) private String username; /** * 密码 */ @TableField(&quot;PASSWORD&quot;) private String password; /** * 部门ID */ @TableField(&quot;DEPT_ID&quot;) private Long deptId; /** * 邮箱 */ @TableField(&quot;EMAIL&quot;) private String email; /** * 联系电话 */ @TableField(&quot;MOBILE&quot;) private String mobile; /** * 状态 0锁定 1有效 */ @TableField(&quot;STATUS&quot;) private String status; /** * 创建时间 */ @TableField(&quot;CREATE_TIME&quot;) private Date createTime; /** * 修改时间 */ @TableField(&quot;MODIFY_TIME&quot;) private Date modifyTime; /** * 最近访问时间 */ @TableField(&quot;LAST_LOGIN_TIME&quot;) private Date lastLoginTime; /** * 性别 0男 1女 2保密 */ @TableField(&quot;SSEX&quot;) private String ssex; /** * 是否开启tab，0关闭 1开启 */ @TableField(&quot;IS_TAB&quot;) private String isTab; /** * 主题 */ @TableField(&quot;THEME&quot;) private String theme; /** * 头像 */ @TableField(&quot;AVATAR&quot;) private String avatar; /** * 描述 */ @TableField(&quot;DESCRIPTION&quot;) private String description; @TableField(exist = false) private List&lt;Role&gt; roles; @TableField(exist = false) private Set&lt;String&gt; perms; /** * 用户权限 * * @return */ /*@Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;GrantedAuthority&gt; auths = new ArrayList&lt;&gt;(); List&lt;Role&gt; roles = this.getRoles(); for (Role role : roles) &#123; auths.add(new SimpleGrantedAuthority(role.getRolePerms())); &#125; return auths; &#125;*/ @Override @JsonIgnore public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;GrantedAuthority&gt; auths = new ArrayList&lt;&gt;(); Set&lt;String&gt; perms = this.getPerms(); for (String perm : perms) &#123; //这里perms值如果为空或空字符会报错 auths.add(new SimpleGrantedAuthority(perm)); &#125; return auths; &#125; @Override @JsonIgnore public boolean isAccountNonExpired() &#123; return true; &#125; @Override @JsonIgnore public boolean isAccountNonLocked() &#123; return true; &#125; @Override @JsonIgnore public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override @JsonIgnore public boolean isEnabled() &#123; return true; &#125;&#125; 注意这里有一个问题 登录用户时，总提示 User account is locked 是因为用户实体类实现UserDetails这个接口时，我默认把所有抽象方法给自动实现了，而自动生成下面这四个方法，默认返回false， 12345678910111213141516171819@Overridepublic boolean isAccountNonExpired() &#123; return false;&#125; @Overridepublic boolean isAccountNonLocked() &#123; return false;&#125; @Overridepublic boolean isCredentialsNonExpired() &#123; return false;&#125; @Overridepublic boolean isEnabled() &#123; return false;&#125; 问题原因就在这里，只要把它们的返回值改成true就行。 UserDetails 中几个字段的解释： &#x2F;&#x2F;返回验证用户密码,无法返回则NULL 12String getPassword();String getUsername(); 账户是否过期,过期无法验证 1boolean isAccountNonExpired(); 指定用户是否被锁定或者解锁,锁定的用户无法进行身份验证 1boolean isAccountNonLocked()； 指示是否已过期的用户的凭据(密码),过期的凭据防止认证 1boolean isCredentialsNonExpired(); 是否被禁用,禁用的用户不能身份验证 1boolean isEnabled(); 实现接口中loadUserByUsername方法注入数据验证就可以了 自己IUserService用户接口类继承Spring Security提供了 UserDetailsService接口 12345678910111213public interface IUserService extends IService&lt;User&gt;, UserDetailsService &#123; User getUserByUsername(String username); /* *//** * 获取用户所有权限 * * @param username * @return *//* Set&lt;String&gt; getUserPerms(String username);*/&#125; 并且加以实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Service@RequiredArgsConstructor@Slf4jpublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123; private final RoleMapper roleMapper; @Override public User getUserByUsername(String username) &#123; return this.baseMapper.selectOne(new QueryWrapper&lt;User&gt;().lambda() .eq(User::getUsername, username)); &#125; /** * 对用户提供的用户详细信息进行身份验证时 * * @param username * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = this.getUserByUsername(username); if (StrUtil.isBlankIfStr(user)) &#123; throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username); &#125; //获取用户角色信息 List&lt;Role&gt; roles = roleMapper.findUserRolePermsByUserName(username); user.setRoles(roles); List&lt;String&gt; permList = this.baseMapper.findUserPerms(username); //java8 stream 便利 Set&lt;String&gt; perms = permList.stream().filter(o-&gt;StrUtil.isNotBlank(o)).collect(Collectors.toSet()); user.setPerms(perms); //用于添加用户的权限。只要把用户权限添加到authorities 就万事大吉。 // List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); //用于添加用户的权限。只要把用户权限添加到authorities 就万事大吉。 /*for (Role role : roles) &#123; authorities.add(new SimpleGrantedAuthority(role.getRolePerms())); log.info(&quot;loadUserByUsername: &quot; + user); &#125;*/ //user.setAuthorities(authorities);//用于登录时 @AuthenticationPrincipal 标签取值 return user; &#125;&#125; 自己实现loadUserByUsername从数据库中验证用户名密码，获取用户角色权限信息 拦截器配置Spring Security的AuthenticationEntryPoint类，它拒绝每个未经身份验证的请求并发送错误代码401 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.soboys.kmall.security.config;import cn.soboys.kmall.common.ret.Result;import cn.soboys.kmall.common.ret.ResultCode;import cn.soboys.kmall.common.ret.ResultResponse;import cn.soboys.kmall.common.utils.ResponseUtil;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.AuthenticationEntryPoint;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Serializable;/** * @author kenx * @version 1.0 * @date 2021/8/5 22:30 * @webSite https://www.soboys.cn/ * 此类继承Spring Security的AuthenticationEntryPoint类， * 并重写其commence。它拒绝每个未经身份验证的请求并发送错误代码401。 */@Componentpublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable &#123; /** * 此类继承Spring Security的AuthenticationEntryPoint类，并重写其commence。 * 它拒绝每个未经身份验证的请求并发送错误代码401 * * @param httpServletRequest * @param httpServletResponse * @param e * @throws IOException * @throws ServletException */ @Override public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; Result result = ResultResponse.failure(ResultCode.UNAUTHORIZED, &quot;请先登录&quot;); ResponseUtil.responseJson(httpServletResponse, result); &#125;&#125; JwtRequestFilter 任何请求都会执行此类检查请求是否具有有效的JWT令牌。如果它具有有效的JWT令牌，则它将在上下文中设置Authentication，以指定当前用户已通过身份验证。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.soboys.kmall.security.config;import cn.soboys.kmall.common.utils.ConstantFiledUtil;import cn.soboys.kmall.security.service.IUserService;import cn.soboys.kmall.security.utils.JwtTokenUtil;import io.jsonwebtoken.ExpiredJwtException;import lombok.extern.slf4j.Slf4j;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;import org.springframework.stereotype.Component;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author kenx * @version 1.0 * @date 2021/8/5 22:27 * @webSite https://www.soboys.cn/ * 任何请求都会执行此类 * 检查请求是否具有有效的JWT令牌。如果它具有有效的JWT令牌， * 则它将在上下文中设置Authentication，以指定当前用户已通过身份验证。 */@Component@Slf4jpublic class JwtRequestFilter extends OncePerRequestFilter &#123; //用户数据源 private IUserService userService; //生成jwt 的token private JwtTokenUtil jwtTokenUtil; public JwtRequestFilter(IUserService userService,JwtTokenUtil jwtTokenUtil) &#123; this.userService = userService; this.jwtTokenUtil = jwtTokenUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; final String requestTokenHeader = request.getHeader(ConstantFiledUtil.AUTHORIZATION_TOKEN); String username = null; String jwtToken = null; // JWT Token is in the form &quot;Bearer token&quot;. Remove Bearer word and get only the Token if (requestTokenHeader != null &amp;&amp; requestTokenHeader.startsWith(&quot;Bearer &quot;)) &#123; jwtToken = requestTokenHeader.substring(7); try &#123; username = jwtTokenUtil.getUsernameFromToken(jwtToken); &#125; catch (IllegalArgumentException e) &#123; log.error(&quot;Unable to get JWT Token&quot;); &#125; catch (ExpiredJwtException e) &#123; log.error(&quot;JWT Token has expired&quot;); &#125; &#125; else &#123; //logger.warn(&quot;JWT Token does not begin with Bearer String&quot;); &#125; //Once we get the token validate it. if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123; UserDetails userDetails = this.userService.loadUserByUsername(username); // if token is valid configure Spring Security to manually set authentication if (jwtTokenUtil.validateToken(jwtToken, userDetails)) &#123; //保存用户信息和权限信息 UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities()); usernamePasswordAuthenticationToken .setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); // After setting the Authentication in the context, we specify // that the current user is authenticated. So it passes the Spring Security Configurations successfully. SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; 配置Spring Security 配置类SecurityConfig 自定义Spring Security的时候我们需要继承自WebSecurityConfigurerAdapter来完成，相关配置重写对应 方法 此处使用了 BCryptPasswordEncoder 密码加密 通过重写configure方法添加我们自定义的认证方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package cn.soboys.kmall.security.config;import cn.soboys.kmall.security.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import java.util.Set;/** * @author kenx * @version 1.0 * @date 2021/8/6 17:27 * @webSite https://www.soboys.cn/ */@EnableWebSecurity@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true) // 控制权限注解public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint; private IUserService userService; private JwtRequestFilter jwtRequestFilter; public SecurityConfig(JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint, IUserService userService, JwtRequestFilter jwtRequestFilter) &#123; this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint; this.userService = userService; this.jwtRequestFilter = jwtRequestFilter; &#125; /** * 1）HttpSecurity支持cors。 * 2）默认会启用CRSF，此处因为没有使用thymeleaf模板（会自动注入_csrf参数）， * 要先禁用csrf，否则登录时需要_csrf参数，而导致登录失败。 * 3）antMatchers：匹配 &quot;/&quot; 路径，不需要权限即可访问，匹配 &quot;/user&quot; 及其以下所有路径， * 都需要 &quot;USER&quot; 权限 * 4）配置登录地址和退出地址 */ @Override protected void configure(HttpSecurity http) throws Exception &#123; // We don&#x27;t need CSRF for this example http.csrf().disable() // dont authenticate this particular request .authorizeRequests().antMatchers(&quot;/&quot;, &quot;/*.html&quot;, &quot;/favicon.ico&quot;, &quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/fonts/**&quot;, &quot;/layui/**&quot;, &quot;/img/**&quot;, &quot;/v3/api-docs/**&quot;, &quot;/swagger-resources/**&quot;, &quot;/webjars/**&quot;, &quot;/pages/**&quot;, &quot;/druid/**&quot;, &quot;/statics/**&quot;, &quot;/login&quot;, &quot;/register&quot;).permitAll(). // all other requests need to be authenticated anyRequest().authenticated().and(). // make sure we use stateless session; session won&#x27;t be used to // store user&#x27;s state. //覆盖默认登录 exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and().sessionManagement() // 基于token，所以不需要session .sessionCreationPolicy(SessionCreationPolicy.STATELESS); // Add a filter to validate the tokens with every request http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; /** * 密码校验 * * @param auth * @throws Exception */ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; // configure AuthenticationManager so that it knows from where to load // user for matching credentials // Use BCryptPasswordEncoder auth.userDetailsService(userService).passwordEncoder(passwordEncoder()); &#125; /** * 密码加密验证 * * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 具体应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package cn.soboys.kmall.security.controller;import cn.hutool.core.util.StrUtil;import cn.soboys.kmall.common.exception.BusinessException;import cn.soboys.kmall.common.ret.ResponseResult;import cn.soboys.kmall.common.ret.Result;import cn.soboys.kmall.common.ret.ResultResponse;import cn.soboys.kmall.security.entity.User;import cn.soboys.kmall.security.service.IUserService;import cn.soboys.kmall.security.utils.EncryptPwdUtil;import cn.soboys.kmall.security.utils.JwtTokenUtil;import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;import io.swagger.annotations.*;import lombok.RequiredArgsConstructor;import lombok.SneakyThrows;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.authentication.DisabledException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotEmpty;import java.util.Date;import java.util.Objects;/** * @author kenx * @version 1.0 * @date 2021/8/6 12:30 * @webSite https://www.soboys.cn/ */@RestController@ResponseResult@Validated@RequiredArgsConstructor@Api(tags = &quot;登录接口&quot;)public class LoginController &#123; private final IUserService userService; //认证管理，认证用户省份 private final AuthenticationManager authenticationManager; private final JwtTokenUtil jwtTokenUtil; //自己数据源 private final UserDetailsService jwtInMemoryUserDetailsService; @PostMapping(&quot;/login&quot;) @ApiOperation(&quot;用户登录&quot;) @SneakyThrows public Result login(@NotBlank @RequestParam String username, @NotBlank @RequestParam String password) &#123; Authentication authentication= this.authenticate(username, password); String user = authentication.getName(); final String token = jwtTokenUtil.generateToken(user); //更新用户最后登录时间 User u = new User(); u.setLastLoginTime(new Date()); userService.update(u, new UpdateWrapper&lt;User&gt;().lambda().eq(User::getUsername, username)); return ResultResponse.success(&quot;Bearer &quot; + token); &#125; @PostMapping(&quot;/register&quot;) @ApiOperation(&quot;用户注册&quot;) public Result register(@NotEmpty @RequestParam String username, @NotEmpty @RequestParam String password) &#123; User user = userService.getUserByUsername(username); if (!StrUtil.isBlankIfStr(user)) &#123; throw new BusinessException(&quot;用户已存在&quot;); &#125; User u = new User(); u.setPassword(EncryptPwdUtil.encryptPassword(password)); u.setUsername(username); u.setCreateTime(new Date()); u.setModifyTime(new Date()); u.setStatus(&quot;1&quot;); userService.save(u); return ResultResponse.success(); &#125; private Authentication authenticate(String username, String password) throws Exception &#123; Authentication authentication = null; try &#123; //security 认证用户身份 authentication = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password)); &#125; catch (DisabledException e) &#123; throw new BusinessException(&quot;用户不存&quot;); &#125; catch (BadCredentialsException e) &#123; throw new BusinessException(&quot;用户名密码错误&quot;); &#125; return authentication; &#125;&#125; 深入了解Spring Security 配置讲解 @EnableWebSecurity 开启权限认证 @EnableGlobalMethodSecurity(prePostEnabled &#x3D; true) 开启权限注解认证 configure 配置 12345678910111213141516171819202122@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // We don&#x27;t need CSRF for this example http.csrf().disable() // dont authenticate this particular request .authorizeRequests().antMatchers(&quot;/&quot;, &quot;/*.html&quot;, &quot;/favicon.ico&quot;, &quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/fonts/**&quot;, &quot;/layui/**&quot;, &quot;/img/**&quot;, &quot;/v3/api-docs/**&quot;, &quot;/swagger-resources/**&quot;, &quot;/webjars/**&quot;, &quot;/pages/**&quot;, &quot;/druid/**&quot;, &quot;/statics/**&quot;, &quot;/login&quot;, &quot;/register&quot;).permitAll(). // all other requests need to be authenticated anyRequest().authenticated().and(). // make sure we use stateless session; session won&#x27;t be used to // store user&#x27;s state. //覆盖默认登录 exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and().sessionManagement() // 基于token，所以不需要session .sessionCreationPolicy(SessionCreationPolicy.STATELESS); // Add a filter to validate the tokens with every request http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);&#125; 参考 Spring Security 权限认证 springSecurity 之 http Basic认证 轻松上手SpringBoot Security + JWT Hello World示例","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"}]}]}