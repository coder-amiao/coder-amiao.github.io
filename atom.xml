<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三时</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-18T08:00:18.133Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>程序员三时</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>细说SpringBoot多种场景传参模式</title>
    <link href="http://example.com/2023/04/18/%E7%BB%86%E8%AF%B4SpringBoot%E5%A4%9A%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%BC%A0%E5%8F%82%E6%A8%A1%E5%BC%8Fclglzfvka00000k6o5grgc75v.html"/>
    <id>http://example.com/2023/04/18/细说SpringBoot多种场景传参模式clglzfvka00000k6o5grgc75v.html</id>
    <published>2023-04-18T07:57:22.590Z</published>
    <updated>2023-04-18T08:00:18.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web技术"><a href="#web技术" class="headerlink" title="web技术"></a>web技术</h1><p>我们知道常见的web技术也就是网站开发，分为静态网站，和动态网站，动态网站技术常见的有三种，分别是 <code>jsp java web</code>，<code>asp c# web</code>,<code>php web</code>但是它们对应请求<code>request</code>,响应<code>response</code> 都是一样的我们用java web开发动态网站用的mvc框架就是，<code>springmvc</code>，当然我们现在用的是<code>springboot </code>它只是对spirng全家桶的一个整合框架，他本质不是一个新的框架，内部还是spirng+springmvc</p><h1 id="多种传参方式"><a href="#多种传参方式" class="headerlink" title="多种传参方式"></a>多种传参方式</h1><h2 id="传统参数传递"><a href="#传统参数传递" class="headerlink" title="传统参数传递"></a>传统参数传递</h2><p>我们知道controller方法中会帮我注入HttpServletRequest对象，我们可以通过<br><code>request.getParameter(&quot;参数名&quot;)</code>来直接获取参数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test01</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(username);</span><br><span class="line">      System.out.println(password);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单类型参数映射"><a href="#简单类型参数映射" class="headerlink" title="简单类型参数映射"></a>简单类型参数映射</h2><ol><li><p>如果请求参数和Controller方法的形参同名，可以直接接收</p></li><li><p>如果请求参数和Controller方法的形参不同名，可以使用@RequestParam注解贴在形参前，设置对应的参数名称</p></li></ol><hr><p><strong>注意</strong>这里只能是<code>基本数据类型</code>比如string，int，long，boolean等类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test02_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test02_1</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">      System.out.println(username);</span><br><span class="line">      System.out.println(password);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test02_2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test02_2</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name,<span class="meta">@RequestParam(value = &quot;password&quot;,defaultValue = &quot;1234987&quot;)</span> String pwd)</span>&#123;</span><br><span class="line">      <span class="comment">//使用了@RequestParam的参数不能传空值</span></span><br><span class="line">      <span class="comment">// required:表示是否必须要传值</span></span><br><span class="line">      <span class="comment">// defaultValue:当没有该请求参数时,SpringMVC给请求参数的默认值</span></span><br><span class="line">      System.out.println(name);</span><br><span class="line">      System.out.println(pwd);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂对象映射"><a href="#复杂对象映射" class="headerlink" title="复杂对象映射"></a>复杂对象映射</h2><p>当然在实际项目中，我们会有很多个参数，一般超过两个参数我们就要封装成对象，通过对象传参数，不然这么一个一个写会麻烦，代码冗余，不美观，不能复用</p><p>此时能够自动把参数封装到形参的对象属性上：</p><ol><li>请求参数必须和对象的属性同名</li><li>此时对象会直接放入request作用域中，名称为类型首字母小写</li><li>@ModelAttribute设置请求参数绑定到对象中并传到视图页面的key值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test03</span><span class="params">(<span class="meta">@ModelAttribute(&quot;stu&quot;)</span> Student student)</span>&#123;</span><br><span class="line">    <span class="comment">/*可以使用对象作为方法的形参,同时接受接受前台的多个请求参数</span></span><br><span class="line"><span class="comment">      SpringMVC会基于同名匹配,将请求参数的值注入对应的对象中的属性中</span></span><br><span class="line"><span class="comment">      @ModelAttribute起名字key值*/</span></span><br><span class="line">      System.out.println(student);</span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">      mv.setViewName(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要body里面json传参数需要在形参前面加上<code>@RequestBody</code> 会自动完成映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">bodyParams</span><span class="params">(<span class="meta">@RequestBody</span> Users users)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ResultResponse.success(users);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="数组和集合类型参数"><a href="#数组和集合类型参数" class="headerlink" title="数组和集合类型参数"></a>数组和集合类型参数</h2><p>当前台页面传来的参数是参数名相同，参数值不同的多个参数时，可以直接封装到方法的数组类型的形参中</p><p>比如批量删除时传来的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于参数名相同的多个请求参数,可以直接使用数组作为方法的形参接收</span></span><br><span class="line"><span class="comment">  可以使用对象中的集合属性接收*/</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/del&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">listParams</span><span class="params">(String[] ids)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultResponse.success(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7943b66cb85b4acc8187f3ffb91797b7~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="Restful风格传参"><a href="#Restful风格传参" class="headerlink" title="Restful风格传参"></a>Restful风格传参</h2><p>Restful是一种软件架构风格，严格上说是一种编码风格，其充分利用 HTTP 协议本身语义从而提供了一组设计原则和约束条件。</p><p>　　主要用于客户端和服务器交互类的软件，该风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 在后台，RequestMapping标签后，可以用{参数名}方式传参，同时需要在形参前加注解@PathVarible</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test4</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web技术&quot;&gt;&lt;a href=&quot;#web技术&quot; class=&quot;headerlink&quot; title=&quot;web技术&quot;&gt;&lt;/a&gt;web技术&lt;/h1&gt;&lt;p&gt;我们知道常见的web技术也就是网站开发，分为静态网站，和动态网站，动态网站技术常见的有三种，分别是 &lt;code&gt;js
      
    
    </summary>
    
      <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
      <category term="SpringBoot" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>集合遍历与循环多种方式</title>
    <link href="http://example.com/2023/04/18/%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8Fclglzfvkq00090k6ocawg0azv.html"/>
    <id>http://example.com/2023/04/18/集合遍历与循环多种方式clglzfvkq00090k6ocawg0azv.html</id>
    <published>2023-04-17T17:39:52.000Z</published>
    <updated>2023-04-18T07:35:01.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Java</code>中集合是非常常用非常重要的 ，应用是十分广泛的，作为集合这种数据结构，遍历循环方式也有很多种我们可以梳理总结不同的遍历方式，方便理解和运用</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9de64203dd634961b07b24cb839c32c9~tplv-k3u1fbpfcp-zoom-1.image"></p><h1 id="List-遍历方式"><a href="#List-遍历方式" class="headerlink" title="List 遍历方式"></a>List 遍历方式</h1><ol><li><p>List继承了Collection，是有序的列表。</p></li><li><p>实现类有ArrayList、LinkedList、Vector、Stack等</p><ol><li><p>ArrayList是基于数组实现的，是一个数组队列。可以动态的增加容量！</p></li><li><p>LinkedList是基于链表实现的，是一个双向循环列表。可以被当做堆栈使用！</p></li><li><p>Vector是基于数组实现的，是一个矢量队列，是线程安全的！</p></li><li><p>Stack是基于数组实现的，是栈，它继承与Vector，特性是FILO（先进后出）！</p></li></ol></li></ol><p>所有list集合都是迭代器<code>Iterator</code>子类也都统称迭代器，可以通过迭代器方式去循环便利</p><ol><li>第一种方式 迭代器遍历<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List a= <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       a.add(<span class="number">1</span>);</span><br><span class="line">       a.add(<span class="number">2</span>);</span><br><span class="line">       a.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取迭代器</span></span><br><span class="line">       Iterator b=a.iterator();</span><br><span class="line">       <span class="comment">//判断是否有下一个值</span></span><br><span class="line">       <span class="keyword">while</span> (b.hasNext())&#123;</span><br><span class="line">           <span class="comment">//取出这个值</span></span><br><span class="line">           System.out.println(b.next());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li>第二种方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List a= <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        a.add(<span class="number">1</span>);</span><br><span class="line">        a.add(<span class="number">2</span>);</span><br><span class="line">        a.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(Iterator iterator=a.iterator();iterator.hasNext();)&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三种方式 foreach 遍历</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List a= <span class="built_in">new</span> ArrayList();</span><br><span class="line">       a.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">       a.<span class="keyword">add</span>(<span class="number">2</span>);</span><br><span class="line">       a.<span class="keyword">add</span>(<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">Object</span> o:a)&#123;</span><br><span class="line">           <span class="keyword">System</span>.<span class="keyword">out</span>.println(o);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>第四种方式 fori 遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List a= <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        a.add(<span class="number">1</span>);</span><br><span class="line">        a.add(<span class="number">2</span>);</span><br><span class="line">        a.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">            System.out.println(a.get(i));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h1><ol><li>按照key方式来遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map a=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      a.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">      a.put(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);</span><br><span class="line">      a.put(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>);</span><br><span class="line">      <span class="comment">//获取所以key</span></span><br><span class="line">      Set key=a.keySet();</span><br><span class="line">      <span class="keyword">for</span>(Object o:key)&#123;</span><br><span class="line">          <span class="comment">//通过key 来获取所有值</span></span><br><span class="line">          System.out.println(a.get(o));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过Map.entrySet使用iterator遍历key和value</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map a=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      a.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">      a.put(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);</span><br><span class="line">      a.put(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>);</span><br><span class="line">      <span class="comment">// 获取Iterator</span></span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = a.entrySet().iterator();</span><br><span class="line">      <span class="comment">//遍历</span></span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">           System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过Map.entrySet遍历key和value，推荐，尤其是容量大时</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map a=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">       a.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>);</span><br><span class="line">       a.put(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);</span><br><span class="line">       a.put(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> ( Object o : a.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//Map.entry&lt;Integer,String&gt; 映射项（键-值对）  有几个方法：用上面的名字entry</span></span><br><span class="line">            <span class="comment">//entry.getKey() ;entry.getValue(); entry.setValue();</span></span><br><span class="line">            <span class="comment">//map.entrySet()  返回此映射中包含的映射关系的 Set视图。</span></span><br><span class="line">            Map.Entry&lt;String,Integer&gt; d=(Map.Entry&lt;String,Integer&gt; )o;</span><br><span class="line">            System.out.println(<span class="string">&quot;key= &quot;</span> + d.getKey() + <span class="string">&quot; and value= &quot;</span> + d.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过Map.values()遍历所有的value，但不能遍历key</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">       a.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       a.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">       a.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span> (Object o : a.values()) &#123;</span><br><span class="line">           System.out.println(o);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流API遍历"><a href="#Stream流API遍历" class="headerlink" title="Stream流API遍历"></a>Stream流API遍历</h1><p> stream集合遍历forEach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="string">&quot;judy&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">a.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">a.stream().forEach(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;中集合是非常常用非常重要的 ，应用是十分广泛的，作为集合这种数据结构，遍历循环方式也有很多种我们可以梳理总
      
    
    </summary>
    
      <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="List" scheme="http://example.com/tags/List/"/>
    
      <category term="Map" scheme="http://example.com/tags/Map/"/>
    
  </entry>
  
</feed>
